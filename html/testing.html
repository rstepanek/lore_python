<!DOCTYPE html>

<html>
<!-- Header -->
<head>
<meta charset="UTF-8">
<title>Live Dash -- Test</title>

	<!-- Links to CSS files here: -->
   <link rel="stylesheet" type="text/css" href="../css/dc.min.css"/>

    <script type="text/javascript" src="../js/d3.v3.min.js"></script>
    <script type="text/javascript" src="../js/underscore-min.js"></script>
    <script type="text/javascript" src="../js/crossfilter.js"></script>
    <script type="text/javascript" src="../js/dc.js"></script>
    
    <!-- ------------------------ -->

</head>
<!-- ------ -->

<body>

<div id="scatter_plot">
    <h4>Positions</h4>
</div>

<div id="line_plot">
    <h4>something here</h4>
</div>


</body>

<!-- Javascript begins here: -->
<script>

gVarsScatter = {
	width: 450,
	height: 450,
	padding: 10,
};


// Here's the scatterplot function:
//function plots() {
	
dc.filterAll();

var points = [];
//"data.csv",
d3.csv("/data", function (error, data) {
    if (error) {
        console.log(error);
    } else {
        console.log("File load successful.");
        // Print loaded data to console:
        console.log(data);
    }

    <!-- //var callback = function(data) { -->
        <!-- data.forEach(function(d) { -->
            <!-- d.x = +d.x; -->
            <!-- d.z = +d.z; -->
            <!-- d.signal = +d.signal; -->

            <!-- //var newPoint = {x: Math.floor(d.x), y: Math.floor(d.z), value: Math.floor(d.signal)}; -->
            <!-- var newPoint = { x: Math.floor(4 * d.x + 200), y: Math.floor(-4 * d.z + 200), value: 2 * (d.signal - 0.5) }; -->
            <!-- //points.push(newPoint); -->
            <!-- points.push(newPoint); -->
            <!-- //console.log(newPoint); -->

        <!-- }); -->

        <!-- //console.log(data);//new -->
        <!-- //console.log(points); -->

        <!-- var index = crossfilter(data); -->

        <!-- var coordDim = index.dimension(function(d) { return [+d.x, +d.z]; }); -->

        <!-- var auxGroup = coordDim.group(); -->

        <!-- var xScale = d3.scale.linear() -->
            <!-- .domain([d3.min(data, function(d) { return d.x; }), d3.max(data, function(d) { return d.x; })]) -->
            <!-- .range([gVarsScatter.width - gVarsScatter.padding, gVarsScatter.padding]); -->


        <!-- var yScale = d3.scale.linear() -->
            <!-- .domain([d3.min(data, function(d) { return d.z; }), d3.max(data, function(d) { return d.z; })]) -->
            <!-- .range([gVarsScatter.height - gVarsScatter.padding, gVarsScatter.padding]); -->

        <!-- var scatterplot = dc.scatterPlot("#scatter_plot"); -->
        <!-- scatterplot -->
            <!-- .width(gVarsScatter.width) -->
            <!-- .height(gVarsScatter.height) -->
            <!-- .dimension(coordDim) -->
            <!-- .x(xScale) -->
            <!-- .y(yScale) -->
            <!-- .brushOn(true) -->
            <!-- .symbolSize(8) -->
            <!-- .clipPadding(10) -->
            <!-- .xAxisLabel("x") -->
            <!-- .yAxisLabel("z") -->
            <!-- .group(auxGroup); -->

        <!-- scatterplot.render(); -->
<!-- //		console.log(points); -->

});
 //   };
    //d3.json("/data", callback);
    /*
d3.csv("data.csv", function (error, data) {
        if (error) {
            console.log(error);
        } else {
            console.log("File load successful.");
            // Print loaded data to console:
            console.log(data);
        }
		
		data.forEach(function(d) {
			d.x = +d.x;
			d.z = +d.z;
			d.signal = +d.signal;
			
			//var newPoint = {x: Math.floor(d.x), y: Math.floor(d.z), value: Math.floor(d.signal)};
			var newPoint = {x: Math.floor(4*d.x + 200), y: Math.floor(-4*d.z + 200), value: 2*(d.signal - 0.5)};
			//points.push(newPoint);
			points.push(newPoint);
			//console.log(newPoint);
			
		});
		
		console.log(points);
		
		var index = crossfilter(data);
	
	    var coordDim = index.dimension(function(d) { return [+d.x, +d.z]; });
		
    	var auxGroup = coordDim.group();
		
		var xScale = d3.scale.linear()
							.domain([d3.min(data, function(d) { return d.x; }), d3.max(data, function(d) { return d.x; })])
							.range([gVarsScatter.width - gVarsScatter.padding, gVarsScatter.padding]);
						
								
		var yScale = d3.scale.linear()
							.domain([d3.min(data, function(d) { return d.z; }), d3.max(data, function(d) { return d.z; })])
							.range([gVarsScatter.height - gVarsScatter.padding, gVarsScatter.padding]);
						
		var scatterplot = dc.scatterPlot("#scatter_plot");
    	scatterplot
		
    			.width(gVarsScatter.width)
    			.height(gVarsScatter.height)
				.dimension(coordDim)
				.x(xScale)
				.y(yScale)
				.brushOn(true)
				.symbolSize(8)
				.clipPadding(10)
				.xAxisLabel("x")
				.yAxisLabel("z")
				.group(auxGroup);
				
		scatterplot.render();
//		console.log(points);
		renderHeatMap(points);
		
});
*/


//function callback(element) {
//	points.push(element);
//}

function reduceAdd(p,v) {
	    	p.signal = p.signal + v.signal;
			p.count = p.count + 1;
			p.avg = p.signal/p.count;
			return p;
};
function reduceRemove(p,v) {
			p.signal = p.signal - v.signal;
			p.count = p.count - 1;
			p.avg = p.signal/p.count;
			return p;
};
function reduceInit() {
			return {
				signal: 0,
				count: 0,
				avg: 0
				};
};

function round_data(d) {
	return Math.round(d);
}

//adds a roundend value to the entire data set
function add_reception_bin(data) {
	_.each(data, function(d) {
	d.binned_reception = round_data(d.coverage);
	}
	);
	return data;
}

//}
		
</script>
<!-- Javascript ends here: -->

</html>
